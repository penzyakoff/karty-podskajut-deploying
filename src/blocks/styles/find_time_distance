def find_time_for_distance(N, intervals, Q, distances):
    # Precompute the positions and velocities at the end of each interval
    positions = [0] * (N + 1)
    velocities = [0] * (N + 1)
    times = [0] * (N + 1)
    
    for i in range(N):
        l, r, a = intervals[i]
        if a > 0:
            t = r - l
            positions[i + 1] = positions[i] + velocities[i] * t + 0.5 * a * t ** 2
            velocities[i + 1] = velocities[i] + a * t
        else:
            t = r - l
            positions[i + 1] = positions[i] + velocities[i] * t
            velocities[i + 1] = velocities[i]
        times[i + 1] = r
    
    results = []
    
    for d in distances:
        left = 0
        right = N
        while left < right:
            mid = (left + right) // 2
            if positions[mid] < d:
                left = mid + 1
            else:
                right = mid
        idx = left - 1
        
        l, r, a = intervals[idx]
        x_start = positions[idx]
        v_start = velocities[idx]
        t_start = times[idx]
        
        if a > 0:
            A = 0.5 * a
            B = v_start
            C = x_start - d
            discriminant = B ** 2 - 4 * A * C
            if discriminant < 0:
                continue
            sqrt_discriminant = discriminant ** 0.5
            t1 = (-B + sqrt_discriminant) / (2 * A)
            t2 = (-B - sqrt_discriminant) / (2 * A)
            t1 += l
            t2 += l
            if t_start <= t1 < r:
                results.append(int(t1))
            elif t_start <= t2 < r:
                results.append(int(t2))
        else:
            t = (d - x_start) / v_start
            if t_start <= t < r:
                results.append(int(t))
    
    return results

# Example usage:
N = 4
intervals = [(0, 2, 1), (2, 4, 0), (4, 6, 2), (6, 7, 0)]
Q = 5
distances = [20, 2, 9, 4, 6]
result = find_time_for_distance(N, intervals, Q, distances)
print(result)